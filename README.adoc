= SushiFast

*Equipe:* Le nain et l'échelle

* BERTRAND Julien
* DEMAZEUX Gabriel

18/02/2022

https://github.com/GlobeTique77/SushiFast[Github du projet]

== Contexte

SushiFast est une application front-end avec le framework Angular qui répond aux besoins d'un scénario professionnel. Un serveur prend la commande de client sur l'application qui sert aussi de carte des menus (l'application fait appel à une api pour récupérer les différentes boxes). Le serveur met dans le panier les boxes commandées par les clients et note le nom du client avant de finaliser la commande et l'envoyer sur le localstorage. Les différents serveurs et cuisiniers peuvent retrouver l'historique des commandes et voir si elles ont été servies et payées, c'est à eux de changer leurs états sur la page de l'historique. Les serveurs doivent aussi montrer la page concernant le RGPD aux clients avant de prendre leurs commandes. +

== Première phase

== Diagrammes

=== Diagramme des cas d'utilisation

image::https://cdn.discordapp.com/attachments/775368238137606184/919983093748752444/Diagramme_de_cas_dutilisation_2.png[]

Ici on a qu'un seul utilisateur, un serveur, qui se chargera de prendre la commande de différents clients.

=== Diagramme des différents tiers

image::https://cdn.discordapp.com/attachments/775368238137606184/920305711089586186/unknown.png[]

SushiFast est le tiers client, c'est l'application angular. +
SushiAPI est le tiers serveur, c'est l'api fait avec nodeJS qui envoiedes requête à la base de données 
avant de répondre aux requêtes reçues du client. +
SushiShop est le tiers base de données, c'est une base de données fait avec MongoDB.

=== Diagramme séquentiel des algorithmes mise en oeuvre pour obtenir les informations des plateaux (Requêtes illustrées sur l’API concernant l’ensemble des plateaux)

image::https://cdn.discordapp.com/attachments/775368238137606184/920247373735817256/Diagramme_de_sequence_basique_3.png[]

Dans SushiFast, BoxesComponent demande les paniers à BoxesService puis les affiches. +
BoxesService demande à SushiAPI les paniers, les reçois au format JSON et les renvoit au composant en JSON.

== RGPD

=== Mentions légales: 

-L'entreprise: SARL SushiFast +
 n°SIRET: 00000000000001

-Adresse de SushiFast: 2bis Rue Edouard Branly, 77000, Melun.

-Informations de contact: +
	mail: julien.bertrand07032002@gmail.com +
	tel: 0600000001

-Directeur de publication: Bertrand Julien

-Hébergeur: SushiFast est son propre hébergeur.

=== Mentions relatives à l’utilisation des données personnelles :

-Le délégue à la protection des données: Demazeux Gabriel +
	mail: demazeux.gabriel@gmail.com +
	tel: 0600000002

-Dans un contexte en ligne, la collecte des données (ici le nom du client) est utilisée afin que le client soit identifié lorsqu'il vient chercher et payer sa commande. +
(SushiFast ne fait pas de livraison mais accepte les commandes en ligne qui sont à récupérer au restaurant)
 Cette donnée est sauvegardée pendant 12 mois maximum (année fiscal) pour les comptes de SushiFast.

-Il est donc obligatoire dans le formulaire de commande de renseigner le nom du client.

-Le destinataire de ces données est uniquement SushiFast.

-Il n'y a aucun cookie qui sera enregistré.

-Lors d'un passage d'une commande, le client a forcément donné son consentement pour renseigner son nom.

-Conformément à la réglementation européenne en vigueur, les Utilisateurs de https://sushifast.com disposent des droits suivants :

droit d'accès (article 15 RGPD) et de rectification (article 16 RGPD), de mise à jour, de complétude des données des Utilisateurs droit de verrouillage ou d’effacement des données des Utilisateurs à caractère personnel (article 17 du RGPD), lorsqu’elles sont inexactes, incomplètes, équivoques, périmées, ou dont la collecte, l'utilisation, la communication ou la conservation est interdite. +
droit de retirer à tout moment un consentement (article 13-2c RGPD). +
droit à la limitation du traitement des données des Utilisateurs (article 18 RGPD). +
droit d’opposition au traitement des données des Utilisateurs (article 21 RGPD). +
droit à la portabilité des données que les Utilisateurs auront fournies, lorsque ces données font l’objet de traitements automatisés fondés sur leur consentement ou sur un contrat (article 20 RGPD). +
droit de définir le sort des données des Utilisateurs après leur mort et de choisir à qui https://sushifast.com devra communiquer (ou non) ses données à un tiers qu’ils aura préalablement désigné. +
Dès que https://sushifast.com a connaissance du décès d’un Utilisateur et à défaut d’instructions de sa part, https://sushifast.com s’engage à détruire ses données, sauf si leur conservation s’avère nécessaire à des fins probatoires ou pour répondre à une obligation légale.

Si l’Utilisateur souhaite savoir comment https://sushifast.com utilise ses Données Personnelles, demander à les rectifier ou s’oppose à leur traitement, l’Utilisateur peut contacter https://sushifast.com par écrit à l’adresse suivante :

SushiFast – DPO, Demazeux Gabriel +
2bis Rue Edouard Branly 77000 Melun. +
Dans ce cas, l’Utilisateur doit indiquer les Données Personnelles qu’il souhaiterait que https://sushifast.com corrige, mette à jour ou supprime, en s’identifiant précisément avec une copie d’une pièce d’identité (carte d’identité ou passeport).

Les demandes de suppression de Données Personnelles seront soumises aux obligations qui sont imposées à https://sushifast.com par la loi, notamment en matière de conservation ou d’archivage des documents. Enfin, les Utilisateurs de https://sushifast.com peuvent déposer une réclamation auprès des autorités de contrôle, et notamment de la CNIL (https://www.cnil.fr/fr/plaintes).

== Structure JSON (interface ts) des commandes dans le localstorage

----
interface BoxesCommande {
    nom: string,
    quantite: number,
    prix: number
}

export interface Commande {
    client: string,
    composition: BoxeCommande[],
    prixTotal: number
}
----
La commande a le nom du client qui l'a commandé pour qu'elle soit reconnaissable.
Ensuite elle contient un tableau de BoxesCommande (les plateaux qui composent la commande avec leur nom, 
la quantité d'un type de panier et le prix total du type de panier)
Et pour finir le prix total de la commande.

== Deuxième phase

== Affichage des plateaux

Tout d'abord, nous devons relier l'application à l'api pour cela on utilise un service. +
sushi.service.ts :
----
import { Injectable } from '@angular/core';
import { Observable, of, throwError } from 'rxjs';
import { Boxe } from 'src/app/model/interfaces/boxe';
import { HttpClient, HttpHeaders, HttpErrorResponse } from '@angular/common/http';
import { GlobalConstants } from 'src/app/global-constants';
import { catchError } from 'rxjs/operators';


@Injectable({
  providedIn: 'root'
})
export class SushiService {

  httpHeader = {
    headers: new HttpHeaders({
    'Content-Type': 'application/json'
    })
    } 

  constructor(private httpClient: HttpClient) { }

  getBoxes(): Observable<any> {
    return this.httpClient.get<Boxe>(this.getBaseUrl() + "/boxes");
  }

  getBaseUrl() : string {                                  
    return GlobalConstants.sushiAPI;
  }

  private handleError(error: HttpErrorResponse): any {
    if (error.error instanceof ErrorEvent) {
    console.error('An error occurred:', error.error.message);
    } else {
    console.error(
    `Backend returned code ${error.status}, ` +
    `body was: ${error.error}`);
    }
    return throwError(() => 'Something bad happened; please try again later.');
    }
    

}
----

C'est le code légèrement modifié du TD CRUD de M.Chamillard. +
On importe l'interface Boxe et GlobalConstants pour sushiAPI qui contient le lien vers l'API. +
Pour récupérer les boxes, on envoie des requêtes HTML avec la fonction getBoxes() pour récupérer des objets de type Boxe. +
Les interfaces Boxe et Ingrédient:
----
import { Ingredient } from "./ingredient";
export interface Boxe {
    id: number,
    nom: string,
    pieces: number,
    composition: Ingredient[],
    saveurs: string[],
    prix: number,
    image: string
}
----

----
export interface Ingredient {
  nom : string,
  quantite : number
}

----
GlobalConstants:
----
export class GlobalConstants {
    static readonly sushiAPI : string  = "http://localhost:3000";
}
----

Ce service est utilisé par le composant BoxeComponent comme c'est lui qui s'occupe d'afficher les boxes. +
BoxesComponents:
----
import { Component, OnInit } from '@angular/core';
import { Boxe } from 'src/app/model/interfaces/boxe';
import { SushiService } from 'src/app/service/sushi/sushi.service';
import { LigneCommande } from 'src/app/classes/ligne-commande';
import { FormControl, FormGroup } from '@angular/forms';
import { Commande, BoxeCommande } from 'src/app/classes/commande';



@Component({
  selector: 'app-boxes',
  templateUrl: './boxes.component.html',
  styleUrls: ['./boxes.component.css']
})

export class BoxesComponent implements OnInit {

  title = 'sushifast';
  boxes: any = [];

  boxe: Boxe = {
    id: 0,
    nom: '',
    pieces: 0,
    composition: [],
    saveurs: [],
    prix: 0.0,
    image: ''
  };

  commandes: LigneCommande[];
  allCommandes: Commande[];
  totalCommande: number = 0.0;
  boxesCommandees = Array();
  boxeCommande: BoxeCommande[];

  showModal: boolean = false;
  commandeForm!: FormGroup;


  constructor(public sushiService: SushiService) {
    this.commandes = [];
    this.boxeCommande = [];
    this.allCommandes = JSON.parse(String(localStorage.getItem("Commandes") || '[]'));
  }

  ngOnInit() {
    this.fetchBoxes()
    this.commandeForm = new FormGroup({
      client: new FormControl(),
      });
     
  }

  fetchBoxes() {
    return this.sushiService.getBoxes().subscribe((data: {}) => {
      this.boxes = data;
      // console.log(data);
    })
  }

  plus(index: number) {
    const nomsBoxesCommandees = this.commandes.map(value => value.nomPlateau);
    const panier: any | Map<string, number> = new Map();
    nomsBoxesCommandees.forEach(nomBoxeCommandee => (panier.set(nomBoxeCommandee, (panier.get(nomBoxeCommandee) || 0) + 1)))
    if (panier.get(this.boxes[index].nom) == 1) {
      for (let i = 0; i < this.commandes.length; i++) {
        if (this.commandes[i].nomPlateau == this.boxes[index].nom) {
          this.commandes[i].quantite++;
          this.commandes[i].prix = this.commandes[i].quantite * this.boxes[index].prix;
          this.commandes[i].prix = Math.round(1000 * this.commandes[i].prix) / 1000;
        }
      }
    }
    else {
      let numCommande = Math.floor(Math.random() * (99 + 1));
      let uneLigne = new LigneCommande(this.boxes[index].image, this.boxes[index].nom, 1, this.boxes[index].prix);
      this.commandes.push(uneLigne);
    }
    this.totalCommande = (this.totalCommande + this.boxes[index].prix);
    this.totalCommande = Math.round(1000 * this.totalCommande) / 1000;
  }

  moins(index: number) {
    const nomsBoxesCommandees = this.commandes.map(value => value.nomPlateau);
    const panier: any | Map<string, number> = new Map();
    nomsBoxesCommandees.forEach(nomBoxeCommandee => (panier.set(nomBoxeCommandee, (panier.get(nomBoxeCommandee) || 0) + 1)))
    if (panier.get(this.boxes[index].nom) == 1) {
      for (let i = 0; i < this.commandes.length; i++) {
        if (this.commandes[i].nomPlateau == this.boxes[index].nom && this.commandes[i].quantite > 0) {
          this.commandes[i].quantite--;
          this.commandes[i].prix = this.commandes[i].quantite * this.boxes[index].prix;
          this.commandes[i].prix = Math.round(1000 * this.commandes[i].prix) / 1000;
        }
        console.log(this.commandes);
        if (this.commandes[i].quantite == 0) {
          this.commandes.splice(i, 1);
        }
        console.log(this.commandes);
      }
      this.totalCommande = this.totalCommande - this.boxes[index].prix;
      this.totalCommande = Math.round(1000 * this.totalCommande) / 1000;
    }
    console.log("Moins :" + index);
  }

  affModal(i: number) {
    if (this.showModal) {
      this.showModal = false;
    } else {
      console.log("Modal indice :" + i);
      console.log("Modal nom plateau :" + this.boxes[i].nom);
      this.boxe = this.boxes[i];
      this.showModal = true;
      // console.log(this.showModal);
    }
  }

  commander() {
    for (let i = 0; i < this.commandes.length; i++) {
      this.boxesCommandees.push(new BoxeCommande(this.commandes[i].nomPlateau, this.commandes[i].quantite, this.commandes[i].prix));
    }
    let uneCommande = new Commande(this.commandeForm.value.client, this.boxesCommandees, this.totalCommande, false, false)

    
    this.allCommandes.push(uneCommande);
    this.commandes = [];
    this.boxesCommandees = [];
    this.totalCommande = 0;
    this.commandeForm.value.client = '';
    let tabItems = JSON.stringify(this.allCommandes);
    localStorage.setItem('Commandes', tabItems);
  }

}
----
Après avoir importé SushiService, on crée un tableau vide: boxes. +
Ensuite on crée la fonction fetchBoxes() qui appele le service pour envoyer une requête HTTP à l'API pour récupérer les boxes et les mettre dans le tableau boxes. +
Comme nous devons voir les boxes au lancement de la page, on fait this.fetchBoxes() dans le ngOnInit(). +

Voici le code qui affiche les boxes dans le boxes.component.html et son UI:
----
<div fxLayout="row wrap">
    <div fxFlex.gt-xs="30%" *ngFor="let item of boxes; let index = index">
        <hr>
        <div class="has-text-centered">{{item.nom}}</div>

        <img [src]="'assets/'+item.image+'.webp'"><br />

        <div class="has-text-centered">
            <button class="button is-link" (click)="plus(index)">+</button>&nbsp;
            <button class="button is-link" (click)="affModal(index)">Détails</button>&nbsp;
            <button class="button is-link" (click)="moins(index)">-</button>
        </div>
    </div>
</div>
----

image::https://cdn.discordapp.com/attachments/775368238137606184/944251011286052924/unknown.png[]

On utilise le module Flex-layout pour bien placer les différentes boxes et la commande ainsi que Bulma pour rendre l'interface plus jolie. +
Pour afficher chaque boxe, on fait un ngFor du tableau boxes pour répeter le code qui suit plusieurs fois pour afficher les plateaux et un index qui est pratique pour des fonctions que nous verrons plus tard. +
Ainsi, nous pouvons afficher le nom et l'image de chaque boxe de sushi. +

== Affichage des détails des plateaux

Vous avez pu voir que dans l'affichage des boxes, il y a une ligne qui affiche le bouton "Détails" et qui quand on clique dessus, appele la fonction affmodal(index). +
Cette fonction permet d'afficher grâce à un modal, les détails du plateau sélectionné avec l'index du ngFor. +
Revoyons le code de affmodal(index) dans boxes.component.ts: 
----
boxe: Boxe = {
    id: 0,
    nom: '',
    pieces: 0,
    composition: [],
    saveurs: [],
    prix: 0.0,
    image: ''
  };
  
showModal: boolean = false;

affModal(i: number) {
    if (this.showModal) {
      this.showModal = false;
    } else {
      console.log("Modal indice :" + i);
      console.log("Modal nom plateau :" + this.boxes[i].nom);
      this.boxe = this.boxes[i];
      this.showModal = true;
    }
  }
----
Comme au départ, showmodal est false, on passe direct au else. +
Mise appart les logs dans la console pour vérifier qu'il prend bien le bon plateau, il prend la boxe de l'index dans boxes et l'attribut à l'objet boxe. +
Puis il met showModal en true pour que le modal s'affiche coté UI grâce à un ngIf que nous pouvons voir maintenant:

----
<div class="modal is-active" *ngIf="showModal">
        <div class="modal-background"></div>
        <div class="modal-content">
            <h1 class="title is-3" style="color:azure;">{{boxe.nom}}</h1>
            <p style="color:yellow;">Nombre de pièces : {{boxe.pieces}}</p>
            <p style="color:yellow;">Composition :</p>
            <ul>
                <li style="color:yellow;" *ngFor="let composition of boxe.composition">{{composition.quantite}}
                    {{composition.nom}}
                </li>
            </ul>
            <p style="color:yellow;">Saveurs :</p>
            <p style="color:yellow;">{{boxe.saveurs}},</p>
            <p style="color:yellow;">Prix : {{boxe.prix}}€</p>
            <img [src]="'assets/'+boxe.image+'.webp'"><br>

            <br>
            <button class="button is-primary" (click)="affModal(0)">Fermer</button>
        </div>
    </div>
----
Comme showModal est true, le test réussi et affiche donc les détails de la boxe dans l'objet boxe qui a été affecté par la fonction affModal(index). +
Cependant, pour afficher la composition, on doit refaire un ngFor comme c'est un tableau d'objets. +

Voici ce que donne l'UI:

image::https://cdn.discordapp.com/attachments/775368238137606184/944251383777996860/unknown.png[]

A la fin du modal, il y a un bouton qui active affModal() mais avec comme paramètre 0. +
Cela permet de réussir le premier if de la fonction comme showModal est true et donc ça le remet en false et ne passe plus le test du ngif. +

== Le panier

Le panier contient les boxes sélectionnées avec leurs images, leurs noms, la quantité et le prix d'un type de boxe multiplié par sa quantité. +
Le panier a, à la toute fin, le prix total de la commande et un formulaire demandant le nom du client pour enregistrer la commande à son nom. +

Pour remplir le panier, il faut cliquer sur le bouton + se trouvant sous chaque plateau pour appeler la méthode plus(index) qui reprend l'index de la boxe sélectionnée. +
Dans boxes.component.ts:
----
commandes: LigneCommande[];
totalCommande: number = 0.0;

plus(index: number) {
    const nomsBoxesCommandees = this.commandes.map(value => value.nomPlateau);
    const panier: any | Map<string, number> = new Map();
    nomsBoxesCommandees.forEach(nomBoxeCommandee => (panier.set(nomBoxeCommandee, (panier.get(nomBoxeCommandee) || 0) + 1)))
    if (panier.get(this.boxes[index].nom) == 1) {
      for (let i = 0; i < this.commandes.length; i++) {
        if (this.commandes[i].nomPlateau == this.boxes[index].nom) {
          this.commandes[i].quantite++;
          this.commandes[i].prix = this.commandes[i].quantite * this.boxes[index].prix;
          this.commandes[i].prix = Math.round(1000 * this.commandes[i].prix) / 1000;
        }
      }
    }
    else {
      let numCommande = Math.floor(Math.random() * (99 + 1));
      let uneLigne = new LigneCommande(this.boxes[index].image, this.boxes[index].nom, 1, this.boxes[index].prix);
      this.commandes.push(uneLigne);
    }
    this.totalCommande = (this.totalCommande + this.boxes[index].prix);
    this.totalCommande = Math.round(1000 * this.totalCommande) / 1000;
  }
----
----
export class LigneCommande {
    constructor(
        public image: string,
        public nomPlateau: string,
        public quantite: number,
        public prix: number
    ) { }
}
----
On récupère les noms des plateaux de la commande en cours qu'on met dans panier puis on compare le nom de la boxe sélectionnée et on vérifie s'il est déjà dans le panier. +
Si oui, on cherche dans commandes si le nom d'une ligne est égale au nom de la boxe sélectionnée, si oui on augmente la quantité de un, on recalcule le prix totale de la ligne (suivi d'une commande qui évite un bug d'affichage du prix). +
Si la boxe n'était pas dans commandes, on crée un nouveau LigneCommande avec les caractéristique souhaité de la boxe sélectionnée qu'on push dans commandes. +
Après on recalcule le total de la commande. +

Le bouton moins retire un élément du panier ou retire de 1 la quantité d'un élément s'il s'y trouve plusieurs fois. +
----
moins(index: number) {
    const nomsBoxesCommandees = this.commandes.map(value => value.nomPlateau);
    const panier: any | Map<string, number> = new Map();
    nomsBoxesCommandees.forEach(nomBoxeCommandee => (panier.set(nomBoxeCommandee, (panier.get(nomBoxeCommandee) || 0) + 1)))
    if (panier.get(this.boxes[index].nom) == 1) {
      for (let i = 0; i < this.commandes.length; i++) {
        if (this.commandes[i].nomPlateau == this.boxes[index].nom && this.commandes[i].quantite > 0) {
          this.commandes[i].quantite--;
          this.commandes[i].prix = this.commandes[i].quantite * this.boxes[index].prix;
          this.commandes[i].prix = Math.round(1000 * this.commandes[i].prix) / 1000;
        }
        console.log(this.commandes);
        if (this.commandes[i].quantite == 0) {
          this.commandes.splice(i, 1);
        }
        console.log(this.commandes);
      }
      this.totalCommande = this.totalCommande - this.boxes[index].prix;
      this.totalCommande = Math.round(1000 * this.totalCommande) / 1000;
    }
    console.log("Moins :" + index);
  }
----
Le code est presque pareil que plus() mais avec quelques tests en plus comme vérifier si la quantité est supérieur à 0, si oui on diminue la quantité de 1 et on recalcule le prix. +
Puis si la quantité devient 0, on supprime l'élément de la commande et on remodifie le prix total de la commande. +

Passons maintenant à l'affichage du panier.
boxes.component.html:
----
<div fxFlex.gt-xs="30%">
            <h1 class="title is-3">Commande</h1>
            <table class="table is-striped center">
                <thead>
                    <tr>
                        <th>Image</th>
                        <th>Plateau</th>
                        <th>Quantite</th>
                        <th>Prix</th>
                    </tr>
                </thead>
                <tbody>
                    <tr *ngFor="let elem of commandes; let index = index">
                        <td><img [src]="'assets/'+elem.image+'.webp'"></td>
                        <td>{{elem.nomPlateau}}</td>
                        <td>{{elem.quantite}}</td>
                        <td>{{elem.prix}}</td>
                    </tr>
                </tbody>
            </table>

            <div style="font-weight:bold;">Total Commande : {{ totalCommande }}</div>
            <form [formGroup]="commandeForm" (ngSubmit)="commander()">
                <div class="field">
                    <div class="control">
                        <input class="input is-link" formControlName="client" type="text" placeholder="nom client" value="">
                    </div>
                </div>
                <div class="field is-grouped">
                    <div class="control">
                        <button class="button is-link">Commander</button>
                    </div>
                </div>
            </form>
----
Le panier vide:

image::https://cdn.discordapp.com/attachments/775368238137606184/944251564326010921/unknown.png[]

Le panier avec quelques plateaux:

image::https://cdn.discordapp.com/attachments/775368238137606184/944251672262221854/unknown.png[]

Nous avons encore du flex-layout et bulma pour la mise en page. +
Le panier est dans un tableau qui pour chaque type de boxe, aura une colonne image, nom, quantité et prix. +
Pour afficher chaque ligne de la commande, on utilise à nouveau ngFor sur le tableau commandes. +
Ensuite nous avons une ligne qui affiche le nombre de la variable totalCommande. +

Et pour finir, un formulaire avec formGroup pour demander le nom du client (c'est précisé dans le input avec le paramètre placeholder). +
Quand le serveur appuiera sur le bouton Commander, ça activera la fonction commander() grâce au ngSubmit. +
Il enregistrera aussi le nom du client dans l'objet FormGroup commandeForm en tant qu'objet FormControl client. +
La méthode commander() enregistrera la commande avec le nom du client dans le localstorage. +

== Sauvegarde dans le localstorage

En appuyant sur Commander, ça lance la méthode commander() qui enregistre la commande dans le local storage. +
----
commandes: LigneCommande[];
  allCommandes: Commande[];
  totalCommande: number = 0.0;
  boxesCommandees = Array();
  boxeCommande: BoxeCommande[];
  
  constructor(public sushiService: SushiService) {
    this.commandes = [];
    this.boxeCommande = [];
    this.allCommandes = JSON.parse(String(localStorage.getItem("Commandes") || '[]'));
  }

commander() {
    for (let i = 0; i < this.commandes.length; i++) {
      this.boxesCommandees.push(new BoxeCommande(this.commandes[i].nomPlateau, this.commandes[i].quantite, this.commandes[i].prix));
    }
    let uneCommande = new Commande(this.commandeForm.value.client, this.boxesCommandees, this.totalCommande, false, false)

    
    this.allCommandes.push(uneCommande);
    this.commandes = [];
    this.boxesCommandees = [];
    this.totalCommande = 0;
    this.commandeForm.value.client = '';
    let tabItems = JSON.stringify(this.allCommandes);
    localStorage.setItem('Commandes', tabItems);
  }
----

classe Commande:
----
export class Commande {
    constructor(
        public client: string,
        public composition: BoxeCommande[],
        public prixTotal: number,
        public servie: boolean,
        public payee: boolean,
    ) {} 
}

export class BoxeCommande {
    constructor(
        public nom: string,
        public quantite: number,
        public prix: number
    ) { }
}
----
Pour chaque LigneCommande dans commandes, on crée un BoxeCommande qu'on met dans un tableau boxeCommandees. +
On crée ensuite une Commande qui reprend le nom du client du formulaire, boxesCommandees, le total de la commande et false, un pour servie (si la commande a été servie) et un pour payee (si la commande a été payée ou non). +
On met uneCommande dans allCommandes et on rénitialise commandes, boxesCommandes, totalCommande et client de commandeForm. +
On stringify allCommandes en JSON dans tabItems qu'on met ensuite dans le localstorage avec comme nom: Commandes. +

== Affichage des commandes du localstorage

On a crée un nouveau component, historique. +
historique.component.ts:
----
import { Component, OnInit } from '@angular/core';
import { LigneCommande } from 'src/app/classes/ligne-commande';

@Component({
  selector: 'app-historique',
  templateUrl: './historique.component.html',
  styleUrls: ['./historique.component.css']
})
export class HistoriqueComponent implements OnInit {

  allCommandes = [];
  detailsCommande = [];
  showModal: boolean = false;
  nomClient: string = '';
  prixCommande: number = 0;
  commandeVide: boolean = false;



  ngOnInit(): void {
    this.allCommandes = JSON.parse(String(localStorage.getItem("Commandes")));
    console.log(this.allCommandes);
    if (this.allCommandes.length == 0) {
      this.commandeVide = true;
      console.log(this.commandeVide);
    }
  }

  delete(index: number) {
    let arrayDataCommande = JSON.parse(String(localStorage.getItem("Commandes")));
    //console.log(arrayDataCommande.length);
    arrayDataCommande.splice(index, 1);
    localStorage.setItem('Commandes', JSON.stringify(arrayDataCommande));
    this.allCommandes = arrayDataCommande;
    if (this.allCommandes.length == 0) {
      this.commandeVide = true;
      console.log(this.commandeVide);
    }
  }

  affModal(i: number) {
    if (this.showModal) {
      this.showModal = false;
    } else {
      this.showModal = true;
      this.detailsCommande = this.allCommandes[i]['composition'];
      this.nomClient = this.allCommandes[i]['client'];
      this.prixCommande = this.allCommandes[i]['prixTotal'];
    }
  }

}
----
Dans le ngOnInit(), on parse le json de Commandes qui est dans le localstorage et on le met dans allCommandes. +
On regarde aussi si le tableau est vide et si oui, on met commandeVide à true. +
Le UI de l'HTML et le code qui affiche les commandes:

image::https://cdn.discordapp.com/attachments/775368238137606184/944254776558911528/unknown.png[]

image::https://cdn.discordapp.com/attachments/775368238137606184/944255033535496212/unknown.png[]

----
<div fxflex.gt-xs="30%">
            <h1 class="title is-3">Historique des commandes</h1>


            <div fxLayout="row wrap">
                <div fxFlex.gt-xs="26%" *ngFor="let commande of allCommandes; let index = index">
                    <hr>
                    <div class="has-text-centered">
                        <h1 class="title is-3">{{commande['client']}}</h1>
                    </div>

                    <div class="bouton">
                        <button class="button is-light" (click)="delete(index)">Supprimer</button>&nbsp;
                        <button class="button is-light" >{{commande['prixTotal']}}€</button>&nbsp;
                        <button class="button is-light" (click)="affModal(index)">Détails</button>
                    </div>
                </div>

                <div class="boxe" *ngIf="commandeVide">
                    <hr>
                    <p>Aucune commande n'a été prise.</p>
                </div>
            </div>
        </div>
----
Avec un ngFor, on affiche les différentes commandes se trouvant dans allCommandes. +
On affiche juste le nom du client avec {{commande['client']}} et des boutons, un qui supprimera la commande du localstorage avec delete(index), un qui affiche le prix total de la commande et qui activera le modal pour afficher les détails avec affmodal(index). +
Nous avons ensuite un ngIf qui dit qu'aucune commande n'a été prise si commandeVide est true. +

affmodal(index) marche de la même façon que celui du component Boxes. +
On met la compostion de la commande, le prix et le nom du client dans des variables. +
Et voici l'HTML du modal: 
----
<div class="modal is-active" *ngIf="showModal">
            <div class="detail">
                <div class="modal-background"></div>
                <div class="modal-content">
                    <h1 class="title is-3" style="color:azure;">Commande {{nomClient}}</h1>
                    <div style="color:yellow;" *ngFor="let detail of detailsCommande">
                        <p>{{detail['quantite']}} {{detail['nom']}}</p>
                    </div>
                    <p style="color:yellow;">Prix: {{prixCommande}}€</p>
                    <br>
                    <button class="button is-primary" (click)="affModal(0)">Fermer</button>
                </div>
            </div>
        </div>
----
Lui aussi fonctionne comme celui de Boxes. +
Les variables contenant la quantité et le nom de chaque boxe qui compose la commande sont cependant différents. +
Et son UI:

image::https://cdn.discordapp.com/attachments/775368238137606184/944255118805716992/unknown.png[]

== Supprimer une commande

C'est le bouton supprimer qui appele la fonction delete(index). +
----
delete(index: number) {
    let arrayDataCommande = JSON.parse(String(localStorage.getItem("Commandes")));
    //console.log(arrayDataCommande.length);
    arrayDataCommande.splice(index, 1);
    localStorage.setItem('Commandes', JSON.stringify(arrayDataCommande));
    this.allCommandes = arrayDataCommande;
    if (this.allCommandes.length == 0) {
      this.commandeVide = true;
      console.log(this.commandeVide);
    }
  }
----
On remet toutes les commandes dans arrayDataCommande puis on retire celui qui a l'index qui est en paramètre. +
On met ensuite dans le localstorage arrayDataCommande qui n'a plus la commande supprimée. +
On actualise allCommandes et on vérifie s'il est égale à 0 pour afficher le message disant qu'il n'y a aucune commande.

== RGPD 

On a crée un component et y avons ajouter le RGPD se trouvant plus haut dans ce README. +

rgpd.component.html:
----
<h1 class="title is-3">Mentions légales:</h1>
<br>
    <h1 class="title is-5">-L’entreprise:</h1><p> SARL SushiFast <br>
    n°SIRET: 00000000000001<br>
    <br>
    </p>
    <h1 class="title is-5">-Adresse de SushiFast:</h1><p> 2bis Rue Edouard Branly, 77000, Melun.<br>
    <br></p>
    <h1 class="title is-5">-Informations de contact:</h1><p><br>
    mail: julien.bertrand07032002@gmail.com<br>
    tel: 0600000001<br>
    <br></p>
    <h1 class="title is-5">-Directeur de publication:</h1><p> Bertrand Julien<br>
    <br></p>
    <h1 class="title is-5">-Hébergeur:</h1><p> SushiFast est son propre hébergeur.<br>
    Mentions relatives à l’utilisation des données personnelles :<br>
    <br></p>
    <h1 class="title is-5">-Le délégue à la protection des données:</h1><p> Demazeux Gabriel<br>
    mail: demazeux.gabriel@gmail.com<br>
    tel: 0600000002<br>
    <br>
    -Dans un contexte en ligne, la collecte des données (ici le nom du client) est utilisée afin que le client soit identifié lorsqu’il vient chercher et payer sa commande.<br>
    (SushiFast ne fait pas de livraison mais accepte les commandes en ligne qui sont à récupérer au restaurant) Cette donnée est sauvegardée pendant 12 mois maximum (année fiscal) pour les comptes de SushiFast.<br>
    <br>
    -Il est donc obligatoire dans le formulaire de commande de renseigner le nom du client.<br>
    <br>
    -Le destinataire de ces données est uniquement SushiFast.<br>
    <br>
    -Il n’y a aucun cookie qui sera enregistré.<br>
    <br>
    -Lors d’un passage d’une commande, le client a forcément donné son consentement pour renseigner son nom.<br>
    <br>
    -Conformément à la réglementation européenne en vigueur, les Utilisateurs de https://sushifast.com disposent des droits suivants :<br>
    <br>
    droit d’accès (article 15 RGPD) et de rectification (article 16 RGPD), de mise à jour, de complétude des données des Utilisateurs droit de verrouillage ou d’effacement des données des Utilisateurs à caractère personnel (article 17 du RGPD), lorsqu’elles sont inexactes, incomplètes, équivoques, périmées, ou dont la collecte, l’utilisation, la communication ou la conservation est interdite.<br>
    droit de retirer à tout moment un consentement (article 13-2c RGPD).<br>
    droit à la limitation du traitement des données des Utilisateurs (article 18 RGPD).<br>
    droit d’opposition au traitement des données des Utilisateurs (article 21 RGPD).<br>
    droit à la portabilité des données que les Utilisateurs auront fournies, lorsque ces données font l’objet de traitements automatisés fondés sur leur consentement ou sur un contrat (article 20 RGPD).<br>
    droit de définir le sort des données des Utilisateurs après leur mort et de choisir à qui https://sushifast.com devra communiquer (ou non) ses données à un tiers qu’ils aura préalablement désigné.<br>
    Dès que https://sushifast.com a connaissance du décès d’un Utilisateur et à défaut d’instructions de sa part, https://sushifast.com s’engage à détruire ses données, sauf si leur conservation s’avère nécessaire à des fins probatoires ou pour répondre à une obligation légale.<br>
    <br>
    Si l’Utilisateur souhaite savoir comment https://sushifast.com utilise ses Données Personnelles, demander à les rectifier ou s’oppose à leur traitement, l’Utilisateur peut contacter https://sushifast.com par écrit à l’adresse suivante :<br>
    <br>
    SushiFast – DPO, Demazeux Gabriel<br>
    2bis Rue Edouard Branly 77000 Melun.<br>
    Dans ce cas, l’Utilisateur doit indiquer les Données Personnelles qu’il souhaiterait que https://sushifast.com corrige, mette à jour ou supprime, en s’identifiant précisément avec une copie d’une pièce d’identité (carte d’identité ou passeport).<br>
    <br>
    Les demandes de suppression de Données Personnelles seront soumises aux obligations qui sont imposées à https://sushifast.com par la loi, notamment en matière de conservation ou d’archivage des documents. Enfin, les Utilisateurs de https://sushifast.com peuvent déposer une réclamation auprès des autorités de contrôle, et notamment de la CNIL (https://www.cnil.fr/fr/plaintes).<br>
    </p>
----
Extrait de l'UI: +

image::https://cdn.discordapp.com/attachments/775368238137606184/944281823238836224/unknown.png[]

== Header et footer

Le header nous sert de navbar, en utilisant le le module rooting d'angular. +
header.component.html et son UI:

image::https://cdn.discordapp.com/attachments/775368238137606184/944297714378747964/unknown.png[]

----
<nav class="navbar" role="navigation" aria-label="main navigation" style="background-color:#485fc7;">
    <div class="navbar-brand">
      <h1 class="title is-1" style="margin-left:30px; color: white;">SushiFast</h1>
    </div>
  
    <div id="menu" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item">
          <div class="buttons">
            <a [routerLink]="['/']" class="button is-light" style="background-color: #485fc7; color: white">
              Commande
            </a>
            <a [routerLink]="['/historique']" class="button is-light" style="background-color: #485fc7; color: white">
              Historique
            </a>
            <a [routerLink]="['/rgpd']" class="button is-light" style="background-color: #485fc7; color: white">
                RGPD
              </a>
          </div>
        </div>
      </div>
    </div>
  </nav>
----
On utilise [routerLink]=['un lien'] pour changer l'url. +
On programme les routes dans app-routing.module.ts:
----
const routes: Routes = [
  { path: '', component: BoxesComponent },
  { path: 'historique', component: HistoriqueComponent },
  { path: 'rgpd', component: RgpdComponent }
];
----
Puis dans app.component.html, on met:
----
<app-header></app-header>
<router-outlet></router-outlet>
<app-footer></app-footer>
----
Le premier pour afficher le component header, le deuxième pour afficher un component en fonction du lien et le troisième pour afficher le component footer.+
Voici le code du footer.component.html:
----
<div class="has-text-centered" style="background-color:rgb(72, 95, 199);color:white">
    <a [routerLink]="['/rgpd']" class="title is-6" style="color:white">Mentions légales</a>
    <p>Equipe: Le nain et l'échelle</p>
</div>
----
Avec un routerLink qui mène au RGPD. +
Et pour finir, son UI: 

image::https://cdn.discordapp.com/attachments/775368238137606184/944286417582968882/unknown.png[]

== Evil User Stories

=== Une arnaque

En tant que personne malveillante, je souhaite nuire l'entreprise SushiFast en commandant beaucoup de plateaux par téléphone mais ne pas venir les chercher et ne pas les payer et ainsi faire perdre de l'argent au restaurant. +

En tant que développeur, je vais limiter le nombre de plateaux par commande pour empêcher un utilisateur malveillant de commander énormémant de plateaux pour qu'au final il ne vienne pas les chercher. Pour cela dans la méthode plus(index) de boxes.component.ts, je rajoute un compteur qui augmente à chaque boxe ajoutée. Si le compteur est à 10, il n'est plus possible de rajouter de boxe à la commande (et retirer un au compteur à chaque utilisation de moins(index) ).

=== Illisible 

En tant que personne malveillante, je souhaite désordonner l'historique des commandes en ajoutant des commandes vides, sans nom ou avec un nom avec énormémant de caractères et ainsi désorganiser la vue de l'historique pour les serveurs et la rendre illisible. +

En tant que développeur, je vais obliger pour passer une commande d'avoir au minimum un plateau dans le panier avec un if dans commander() de boxes.component.ts pour vérifier combien il y a de plateau et s'il n'y en a pas de ne pas enregistrer la commande dans le localstorage. J'utilise la même méthode pour vérifier que le nom du client n'est pas vide. Je vais aussi mettre une limite de caractère au nom du client (16 caractères), encore une fois, il suffit d'un if dans commander() puis renseigner un message d'erreur pour chaque cas.

== Conclusion 

On a fait la majorité de la mission même s'ils nous manquent certaines choses comme les tests unitaires, la réalisation des contres mesures des EVS et par exemple modifier l'état d'une commande dans le localstorage comme elles ont comme propriétés booléenne payee et servie. +
Nous avons mal géré notre temps en ayant mal jugé la dose de travail. 
